<!DOCTYPE html><html><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-W055DP4N3J"></script><script>
					window.dataLayer = window.dataLayer || [];
					function gtag(){dataLayer.push(arguments);}
					gtag('js', new Date());
					gtag('config', 'G-W055DP4N3J');</script><head><meta charSet="utf-8"/><meta name="description" content="기록 저장소"/><meta property="og:description" content="기록 저장소"/><meta property="og:url" content="https://mitny.github.io"/><meta property="og:type" content="website"/><meta property="og:locale" content="ko_KR"/><meta property="og:site_name" content="MitNy.log"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><title>[WEB] JWT(JSON Web Token) |  MitNy.log</title><meta name="robots" content="index,follow"/><meta property="og:title" content="[WEB] JWT(JSON Web Token) |  MitNy.log"/><link rel="canonical" href="https://mitny.github.io/articles/2019-01-01-jwt"/><meta name="next-head-count" content="12"/><meta name="naver-site-verification" content="b408dee953bcbbb1038384f191f36dac0551c0fb"/><meta name="google-site-verification" content="vUtYhRYNCWYYTdurCRaVmtnWpPLuXKKwRAm5F6R9sNs"/><link rel="preload" href="/_next/static/css/e6a7c67d207b98b3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e6a7c67d207b98b3.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-005bdf76005efab4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-14a2a9a26060c1d3.js" defer=""></script><script src="/_next/static/chunks/401-9f1400d964d6d7ce.js" defer=""></script><script src="/_next/static/chunks/pages/articles/%5Bdir_slug%5D/%5Bslug%5D-0b7b92862b8a360a.js" defer=""></script><script src="/_next/static/nJPyYqODS0udXw2rMLLyn/_buildManifest.js" defer=""></script><script src="/_next/static/nJPyYqODS0udXw2rMLLyn/_ssgManifest.js" defer=""></script></head><link rel="apple-touch-icon" sizes="57x57" href="/favicon/apple-icon-57x57.png"/><link rel="apple-touch-icon" sizes="60x60" href="/favicon/apple-icon-60x60.png"/><link rel="apple-touch-icon" sizes="72x72" href="/favicon/apple-icon-72x72.png"/><link rel="apple-touch-icon" sizes="76x76" href="/favicon/apple-icon-76x76.png"/><link rel="apple-touch-icon" sizes="114x114" href="/favicon/apple-icon-114x114.png"/><link rel="apple-touch-icon" sizes="120x120" href="/favicon/apple-icon-120x120.png"/><link rel="apple-touch-icon" sizes="144x144" href="/favicon/apple-icon-144x144.png"/><link rel="apple-touch-icon" sizes="152x152" href="/favicon/apple-icon-152x152.png"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-icon-180x180.png"/><link rel="icon" type="image/png" sizes="192x192" href="/favicon/android-icon-192x192.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/favicon/favicon-96x96.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/manifest.json"/><meta name="msapplication-TileColor" content="#ffffff"/><meta name="msapplication-TileImage" content="/favicon/ms-icon-144x144.png"/><meta name="theme-color" content="#ffffff"/><body><div id="__next" data-reactroot=""><div class="header h-16 bg-white drop-shadow-md text-black"><div class="mx-10 pt-3 cursor-pointer"><p class="header-home text-3xl float-left">MitNy.log</p><p class="text-base font-bold pt-2 float-right">About</p></div></div><div class="mx-10 my-8"><div class="w-full min-h-screen pb-24 mt-8"><div class="w-full min-h-screen pb-24 mt-8"><article class="prose max-w-none"><div class="border-b"><p class="text-4xl font-bold mb-0">[WEB] JWT(JSON Web Token)</p><p class="text-xs text-neutral-500"></p></div><div><p>얼마 전에 WAS를 구현하느라 쿠키나 세션이 아닌 토큰을 사용해 볼 기회가 있었다.
<a href="https://jwt.io/" target="_blank" rel="noopener noreferrer">jwt.io</a>에 가보면 JSON Web Token에 대한 자세한 설명을 볼 수 있고, 토큰을 디코딩할 수 있다.</p>
<!--more-->
<h2 id="jwtjson-web-token-란">JWT(JSON Web Token) 란?</h2>
<ul>
<li>JWT는 JSON을 이용한 토큰이며, 다음과 같은 구조를 가진다.
<img src="/assets/posts/jwt/jwt-io.png" alt=""></li>
</ul>
<ol>
<li>Header : 암호화 알고리즘 및 Type</li>
</ol>
<ul>
<li>typ : 토큰 타입, JWT만 존재</li>
<li>alg : 해싱 알고리즘(HMAC SHA256 또는 RSA) 헤더 자체를 암호화하는 것이 아닌 토큰 검증 시에 사용된다.</li>
</ul>
<ol start="2">
<li>Payload : 실제 토큰으로 사용하려는 데이터가 담긴 부분</li>
</ol>
<ul>
<li>
<p>Reserved claims : 이미 예약된 Claim</p>
<ul>
<li>iss(String) : issuse, 토큰 발행자 정보</li>
<li>exp(Number) : expiration time, 만료일</li>
<li>sub(String) : subject, 제목</li>
<li>aud(String) : audience</li>
</ul>
</li>
<li>
<p>Public claims : 사용자 정의 Claim</p>
<ul>
<li>공개용 정보, URI 포맷을 이용해 저장</li>
</ul>
</li>
<li>
<p>Private cliams : 사용자 정의 Claim</p>
<ul>
<li>사용자가 임의로 정한 정보</li>
</ul>
</li>
</ul>
<ol start="3">
<li>Signature : Header와 Payload의 데이터 무결성과 변조 방지를 위한 서명</li>
</ol>
<ul>
<li>Header와 Payload를 합친 후 Secret 키와 함께 Header의 해싱 알고리즘으로 인코딩</li>
</ul>
<br>
## JWT의 인증방식
 - 토큰 기반 시스템은 상태유지를 하지 않으므로 stateless 하다.
 - 클라이언트가 토큰을 서버에 전달할 때 HTTP 요청 헤더에 포함시켜 전달한다.
![](/assets/posts/jwt/token-diagram.png)
<br>
## JWT의 문제점
<ol>
<li>길이</li>
</ol>
<ul>
<li>Claim에 넣는 데이터와 JWT 토큰의 길ㅑ이는 비례한다. 클라이언트가 요청할 때마다 헤더에 토큰이 붙어 전송되므로, 네트워크 대역폭 낭비가 심하다.</li>
</ul>
<ol start="2">
<li>한번 발급된 토큰 값의 수정 및 폐기 불가능</li>
</ol>
<ul>
<li>JWT는 토큰 내에 모든 정보를 가지고 있어 한번 발급된 토큰을 서버가 변경할 수 없다. 그렇기 때문에 Reserved Claims에 expiration time을 꼭 지정해주고, refresh token 등을 통해 토큰을 재발급해주어야 한다.</li>
</ul>
<ol start="3">
<li>보안</li>
</ol>
<ul>
<li>기본적으로 Claim을 암호화 하지 않고 단순히 base64 인코딩만을 하기 때문에 토큰이 타인에게 노출되면 사용자 정보가 유출될 수 있다.</li>
<li>Payload에 권한과 관련된 Claim을 넣어 그 값으로만 사용자를 식별한다면 토큰 값 조작으로 인가되지 않은 접근 권한을 획득할 수 있다.</li>
</ul>
<br>
## 보안 고려사항
<ol>
<li>Signature Stripping</li>
</ol>
<ul>
<li>JWT 공격 방법 중 signature를 제거하는 것이 흔하다. 잘못된 검증으로 unsigned 상태인 토큰을 유효한 토큰으로 인식할 수 있으므로 애플리케이션에서 unsigned 토큰을 유효하지 않은 토큰으로 인식하도록 하면 된다.</li>
</ul>
<ol start="2">
<li>CSRF(Cross-Site Request Forgery)</li>
</ol>
<ul>
<li>토큰이 쿠키에 저장되는 경우, short-lived JWT를 이용하거나, origin 검증을 통해 CSRF 공격을 방어할 수 있다. 토큰이 쿠키에 저장되어있지 않으면 CSRF 공격은 불가능하다.</li>
</ul>
<ol start="3">
<li>XSS(Cross-Site Scripting)</li>
</ol>
<ul>
<li>액세스 토큰이 만료되기 전에 유출되면, 리소스에 접근하는 용도로 사용될 수 있다. 클라이언트에서 보낸 데이터를 반드시 sanitize 하고, 쿠키에 대해선 HttpOnly flag를 설정해 스크립트 코드로 접근하는 것을 막아야 한다.</li>
</ul></div></article></div></div></div><footer class="h-16 bg-neutral-500"></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slug":"2019-01-01-jwt","content":"\n얼마 전에 WAS를 구현하느라 쿠키나 세션이 아닌 토큰을 사용해 볼 기회가 있었다.\n[jwt.io](https://jwt.io/)에 가보면 JSON Web Token에 대한 자세한 설명을 볼 수 있고, 토큰을 디코딩할 수 있다.\n\n\u003c!--more--\u003e\n\n## JWT(JSON Web Token) 란?\n - JWT는 JSON을 이용한 토큰이며, 다음과 같은 구조를 가진다.\n![](/assets/posts/jwt/jwt-io.png)\n\n 1) Header : 암호화 알고리즘 및 Type\n  - typ : 토큰 타입, JWT만 존재\n  - alg : 해싱 알고리즘(HMAC SHA256 또는 RSA) 헤더 자체를 암호화하는 것이 아닌 토큰 검증 시에 사용된다.\n\n 2) Payload : 실제 토큰으로 사용하려는 데이터가 담긴 부분\n  - Reserved claims : 이미 예약된 Claim\n     - iss(String) : issuse, 토큰 발행자 정보\n     - exp(Number) : expiration time, 만료일\n     - sub(String) : subject, 제목\n     - aud(String) : audience\n\n  - Public claims : 사용자 정의 Claim\n     - 공개용 정보, URI 포맷을 이용해 저장\n\n  - Private cliams : 사용자 정의 Claim\n     - 사용자가 임의로 정한 정보\n\n\n 3) Signature : Header와 Payload의 데이터 무결성과 변조 방지를 위한 서명\n  - Header와 Payload를 합친 후 Secret 키와 함께 Header의 해싱 알고리즘으로 인코딩\n\n\u003cbr\u003e\n## JWT의 인증방식\n - 토큰 기반 시스템은 상태유지를 하지 않으므로 stateless 하다.\n - 클라이언트가 토큰을 서버에 전달할 때 HTTP 요청 헤더에 포함시켜 전달한다.\n![](/assets/posts/jwt/token-diagram.png)\n\n\u003cbr\u003e\n## JWT의 문제점\n\n  1) 길이\n   - Claim에 넣는 데이터와 JWT 토큰의 길ㅑ이는 비례한다. 클라이언트가 요청할 때마다 헤더에 토큰이 붙어 전송되므로, 네트워크 대역폭 낭비가 심하다.\n\n  2) 한번 발급된 토큰 값의 수정 및 폐기 불가능\n   - JWT는 토큰 내에 모든 정보를 가지고 있어 한번 발급된 토큰을 서버가 변경할 수 없다. 그렇기 때문에 Reserved Claims에 expiration time을 꼭 지정해주고, refresh token 등을 통해 토큰을 재발급해주어야 한다.\n\n  3) 보안\n   - 기본적으로 Claim을 암호화 하지 않고 단순히 base64 인코딩만을 하기 때문에 토큰이 타인에게 노출되면 사용자 정보가 유출될 수 있다.\n   - Payload에 권한과 관련된 Claim을 넣어 그 값으로만 사용자를 식별한다면 토큰 값 조작으로 인가되지 않은 접근 권한을 획득할 수 있다. \n\n\u003cbr\u003e\n## 보안 고려사항\n\n  1) Signature Stripping\n   - JWT 공격 방법 중 signature를 제거하는 것이 흔하다. 잘못된 검증으로 unsigned 상태인 토큰을 유효한 토큰으로 인식할 수 있으므로 애플리케이션에서 unsigned 토큰을 유효하지 않은 토큰으로 인식하도록 하면 된다.\n\n  2) CSRF(Cross-Site Request Forgery)\n   - 토큰이 쿠키에 저장되는 경우, short-lived JWT를 이용하거나, origin 검증을 통해 CSRF 공격을 방어할 수 있다. 토큰이 쿠키에 저장되어있지 않으면 CSRF 공격은 불가능하다.\n\n  3) XSS(Cross-Site Scripting)\n   - 액세스 토큰이 만료되기 전에 유출되면, 리소스에 접근하는 용도로 사용될 수 있다. 클라이언트에서 보낸 데이터를 반드시 sanitize 하고, 쿠키에 대해선 HttpOnly flag를 설정해 스크립트 코드로 접근하는 것을 막아야 한다.\n","layout":"post","title":"[WEB] JWT(JSON Web Token)","categories":["WEB"],"excerpt":" ","comments":true,"share":true,"tags":["web","JWT"]}},"__N_SSG":true},"page":"/articles/[dir_slug]/[slug]","query":{"dir_slug":"2019-01","slug":"jwt"},"buildId":"nJPyYqODS0udXw2rMLLyn","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>